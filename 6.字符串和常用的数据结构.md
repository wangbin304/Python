# python 里面不同的数据类型如何定义
i = None
i = null
i = 0 (数值类型)
i = '' （两个单引号） 或 i = "" (这是字符串类型)
i = [] (列表类型)
i = {}（字典类型）
i = () （元祖类型）

# 使用字符串
```
def main():
    str1='hello,world!'
    print(len(str1))
    #12
    print(str1.capitalize())
    #Hello,world!   首字母大写
    print(str1.upper())
    #HELLO,WORLD!  全部字母大写
    print(str1.find('or'))
    #7
    print(str1.find('shit'))
    #-1  没找到 返回-1
    #print(str1.index('shit'))
    #与find类似但找不到子串时会引发异常
    print(str1.startswith('He'))#False
    print(str1.startswith('he'))#True
    print(str1.endswith('!'))#True
    print(str1.endswith('d'))#False
    print(str1.center(19,'*'))
    #****hello,world!*** 将字符串以指定的宽度居中并在两侧填充指定的字符
    print(str1.rjust(20,' '))
    #        hello,world!
    #将字符以指定的宽度靠右放置左侧填充指定的字符
    str2='abc123456'
    print(str2[2])
    #c  从字符串中去除指定位置的字符（下标运算）

    #字符串切片（从指定的开始索引到制定的结束索引）
    print(str2[2:5]) #c12
    print(str2[2:]) #c123456
    print(str2[2::2])#c246
    print(str2[::2])#ac246
    print(str2[::-1])#654321cba
    print(str2[-3:-1])#45

    #检查字符串是否由数字构成
    print(str2.isdigit())#False
    #检查字符串是否以数字和字母构成
    print(str2.isalnum())#True

    str3=' jackfrue@126.com    '
    print(str3.strip())#jackfrue@126.com

    print()
if __name__=='__main__':
    main()
   ```
   
   除了字符串，Python还内置了多种类型的数据结构，如果要在程序中保存和操作数据，
绝大多数时候可以利用现有的数据结构来实现，最常用的包括列表、元组、集合和字典。



# 使用列表
1）使用列表
下面的代码演示了如何定义列表、使用下标访问列表元素以及添加和删除元素的操作。

```
def main():
    list1=[1,3,5,7,100]
    print(list1)
    list2=['hello']*5
    print(list2)  #5
    #计算列表长度（元素个数）
    print(len(list1))  #5
    print(len(list2))  #5

    #下标（索引）运算
    print(list1[0])  #1
    print(list1[4])  #100
    #print(list1[5]) #IndexError: list index out of range
    print(list1[-1]) #100
    print(list1[-3]) #5
    list1[2]=300
    print(list1)  #[1, 3, 300, 7, 100]

    #添加元素
    list1.append(200)  #append 追加，增补
    list1 += [1000, 2000]
    list1.insert(1,400)  #加在一的位置  400
    print(list1)
    print(len(list1))

    #删除元素
    list1.remove(3) 
    if 1234 in list1:
        list1.remove(1234)
    del list1[0]
    print(list1) #[400, 300, 7, 100, 200, 1000, 2000]

    #清空列表元素
    list1.clear() 
    print(list1)  #[]
if __name__=='__main__':
    main()
```



2)和字符串一样，列表也可以做切片操作，通过切片操作我们可以实现对列表的复制或者将列表中的一部分取出来创建出新的列表，代码如下所示。
```
def main():
    fruits=['grape','apple','strawberry','waxberry']
    fruits+=['pitaya','pear','mango']
    #循环遍历列表元素
    for fruit in fruits:
        print(fruit.title(),end=' ')
    print()
    #列表切片
    fruits2=fruits[1:4]
    print(fruits2)
    #fruit3=fruits  #没有复制列表只创建了新的引用
    #可以通过完整切片操作来复制列表
    fruits3=fruits[:]
    print(fruits3)
    fruits4=fruits[-3:-1]
    print(fruits4)
    #可以通过反向切片操作来获得倒转后的列表的拷贝
    fruits5=fruits[::-1]
    print(fruits5)
if __name__=='__main__':
    main()




Grape Apple Strawberry Waxberry Pitaya Pear Mango 
['apple', 'strawberry', 'waxberry']
['grape', 'apple', 'strawberry', 'waxberry', 'pitaya', 'pear', 'mango']
['pitaya', 'pear']
['mango', 'pear', 'pitaya', 'waxberry', 'strawberry', 'apple', 'grape']

```


下面的代码实现了对列表的排序操作。
```
def main():
    list1=['orange','apple','zoo','internationalization','blueberry']
    list2=sorted(list1)
    #sorted函数返回 列表排序后 的拷贝不会修改传入的列表
    #函数的设计就应该像sorted函数一样尽可能不产生副作用
    list3=sorted(list1,reverse=True)
    #通过key关键字参数指定根据字符串长度而不是默认的字母表顺序
    list4=sorted(list1,key=len)
    print(list1)
    print(list2)
    print(list3)
    print(list4)
    #给列表对象发送排序消息直接在列表对象上进行排序
    list1.sort(reverse=True)
    print(list1)
if __name__=="__main__":
    main()
```



我们还可以使用列表的生成式语法来创建列表，代码如下所示。

```
import sys
def main():
    f=[x for x in range(1,10)]
    print(f)
    f=[x+y for x in 'ABCDE' for y in '1234567']
    print(f)
    # 用列表的生成表达式语法创建列表容器
    #用这种语法创建列表之后元素已经准备就绪所以需要消耗较多的存储空间
    f=[x**2 for x in range(1,1000)]
    print(sys.getsizeof(f)) #查看对象占用内存的字节数
    print(f)
    #请注意下面的代码创建的不是一个列表而是一个生成器对象
    #通过生成器可以获得到数据但它不占用额外的空间存储数据
    #每次需要数据的时候就通过内部的运算得到数据（需要花费额外的时间）
    f=(x**2 for x in range(1,1000))
    print(sys.getsizeof(f))#相比生成式生成器不占用存储数据的空间
    print(f)
    for val in f:
        print(val)

if __name__=='__main__':
    main()
    
    [1, 2, 3, 4, 5, 6, 7, 8, 9]
['A1', 'A2', 'A3', 'A4', 'A5', 'A6', 'A7', 'B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7', 'C1', 'C2', 'C3', 'C4', 'C5', 'C6', 'C7', 'D1', 'D2', 'D3', 'D4', 'D5', 'D6', 'D7', 'E1', 'E2', 'E3', 'E4', 'E5', 'E6', 'E7']
9024
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225, 256, 289, 324, 361, 400, 441, 484, 529, 576, 625, 676, 729, 784, 841, 900, 961, 1024, 1089, 1156, 1225, 1296, 1369, 1444, 1521, 1600, 1681, 1764, 1849, 1936, 2025, 2116, 2209, 2304, 2401, 2500, 2601, 2704, 2809, 2916, 3025, 3136, 3249, 3364, 3481, 3600, 3721, 3844, 3969, 4096, 4225, 4356, 4489, 4624, 4761, 4900, 5041, 5184, 5329, 5476, 5625, 5776, 5929, 6084, 6241, 6400, 6561, 6724, 6889, 7056, 7225, 7396, 7569, 7744, 7921, 8100, 8281, 8464, 8649, 8836, 9025, 9216, 9409, 9604, 9801, 10000, 10201, 10404, 10609, 10816, 11025, 11236, 11449, 11664, 11881, 12100, 12321, 12544, 12769, 12996, 13225, 13456, 13689, 13924, 14161, 14400, 14641, 14884, 15129, 15376, 15625, 15876, 16129, 16384, 16641, 16900, 17161, 17424, 17689, 17956, 18225, 18496, 18769, 19044, 19321, 19600, 19881, 20164, 20449, 20736, 21025, 21316, 21609, 21904, 22201, 22500, 22801, 23104, 23409, 23716, 24025, 24336, 24649, 24964, 25281, 25600, 25921, 26244, 26569, 26896, 27225, 27556, 27889, 28224, 28561, 28900, 29241, 29584, 29929, 30276, 30625, 30976, 31329, 31684, 32041, 32400, 32761, 33124, 33489, 33856, 34225, 34596, 34969, 35344, 35721, 36100, 36481, 36864, 37249, 37636, 38025, 38416, 38809, 39204, 39601, 40000, 40401, 40804, 41209, 41616, 42025, 42436, 42849, 43264, 43681, 44100, 44521, 44944, 45369, 45796, 46225, 46656, 47089, 47524, 47961, 48400, 48841, 49284, 49729, 50176, 50625, 51076, 51529, 51984, 52441, 52900, 53361, 53824, 54289, 54756, 55225, 55696, 56169, 56644, 57121, 57600, 58081, 58564, 59049, 59536, 60025, 60516, 61009, 61504, 62001, 62500, 63001, 63504, 64009, 64516, 65025, 65536, 66049, 66564, 67081, 67600, 68121, 68644, 69169, 69696, 70225, 70756, 71289, 71824, 72361, 72900, 73441, 73984, 74529, 75076, 75625, 76176, 76729, 77284, 77841, 78400, 78961, 79524, 80089, 80656, 81225, 81796, 82369, 82944, 83521, 84100, 84681, 85264, 85849, 86436, 87025, 87616, 88209, 88804, 89401, 90000, 90601, 91204, 91809, 92416, 93025, 93636, 94249, 94864, 95481, 96100, 96721, 97344, 97969, 98596, 99225, 99856, 100489, 101124, 101761, 102400, 103041, 103684, 104329, 104976, 105625, 106276, 106929, 107584, 108241, 108900, 109561, 110224, 110889, 111556, 112225, 112896, 113569, 114244, 114921, 115600, 116281, 116964, 117649, 118336, 119025, 119716, 120409, 121104, 121801, 122500, 123201, 123904, 124609, 125316, 126025, 126736, 127449, 128164, 128881, 129600, 130321, 131044, 131769, 132496, 133225, 133956, 134689, 135424, 136161, 136900, 137641, 138384, 139129, 139876, 140625, 141376, 142129, 142884, 143641, 144400, 145161, 145924, 146689, 147456, 148225, 148996, 149769, 150544, 151321, 152100, 152881, 153664, 154449, 155236, 156025, 156816, 157609, 158404, 159201, 160000, 160801, 161604, 162409, 163216, 164025, 164836, 165649, 166464, 167281, 168100, 168921, 169744, 170569, 171396, 172225, 173056, 173889, 174724, 175561, 176400, 177241, 178084, 178929, 179776, 180625, 181476, 182329, 183184, 184041, 184900, 185761, 186624, 187489, 188356, 189225, 190096, 190969, 191844, 192721, 193600, 194481, 195364, 196249, 197136, 198025, 198916, 199809, 200704, 201601, 202500, 203401, 204304, 205209, 206116, 207025, 207936, 208849, 209764, 210681, 211600, 212521, 213444, 214369, 215296, 216225, 217156, 218089, 219024, 219961, 220900, 221841, 222784, 223729, 224676, 225625, 226576, 227529, 228484, 229441, 230400, 231361, 232324, 233289, 234256, 235225, 236196, 237169, 238144, 239121, 240100, 241081, 242064, 243049, 244036, 245025, 246016, 247009, 248004, 249001, 250000, 251001, 252004, 253009, 254016, 255025, 256036, 257049, 258064, 259081, 260100, 261121, 262144, 263169, 264196, 265225, 266256, 267289, 268324, 269361, 270400, 271441, 272484, 273529, 274576, 275625, 276676, 277729, 278784, 279841, 280900, 281961, 283024, 284089, 285156, 286225, 287296, 288369, 289444, 290521, 291600, 292681, 293764, 294849, 295936, 297025, 298116, 299209, 300304, 301401, 302500, 303601, 304704, 305809, 306916, 308025, 309136, 310249, 311364, 312481, 313600, 314721, 315844, 316969, 318096, 319225, 320356, 321489, 322624, 323761, 324900, 326041, 327184, 328329, 329476, 330625, 331776, 332929, 334084, 335241, 336400, 337561, 338724, 339889, 341056, 342225, 343396, 344569, 345744, 346921, 348100, 349281, 350464, 351649, 352836, 354025, 355216, 356409, 357604, 358801, 360000, 361201, 362404, 363609, 364816, 366025, 367236, 368449, 369664, 370881, 372100, 373321, 374544, 375769, 376996, 378225, 379456, 380689, 381924, 383161, 384400, 385641, 386884, 388129, 389376, 390625, 391876, 393129, 394384, 395641, 396900, 398161, 399424, 400689, 401956, 403225, 404496, 405769, 407044, 408321, 409600, 410881, 412164, 413449, 414736, 416025, 417316, 418609, 419904, 421201, 422500, 423801, 425104, 426409, 427716, 429025, 430336, 431649, 432964, 434281, 435600, 436921, 438244, 439569, 440896, 442225, 443556, 444889, 446224, 447561, 448900, 450241, 451584, 452929, 454276, 455625, 456976, 458329, 459684, 461041, 462400, 463761, 465124, 466489, 467856, 469225, 470596, 471969, 473344, 474721, 476100, 477481, 478864, 480249, 481636, 483025, 484416, 485809, 487204, 488601, 490000, 491401, 492804, 494209, 495616, 497025, 498436, 499849, 501264, 502681, 504100, 505521, 506944, 508369, 509796, 511225, 512656, 514089, 515524, 516961, 518400, 519841, 521284, 522729, 524176, 525625, 527076, 528529, 529984, 531441, 532900, 534361, 535824, 537289, 538756, 540225, 541696, 543169, 544644, 546121, 547600, 549081, 550564, 552049, 553536, 555025, 556516, 558009, 559504, 561001, 562500, 564001, 565504, 567009, 568516, 570025, 571536, 573049, 574564, 576081, 577600, 579121, 580644, 582169, 583696, 585225, 586756, 588289, 589824, 591361, 592900, 594441, 595984, 597529, 599076, 600625, 602176, 603729, 605284, 606841, 608400, 609961, 611524, 613089, 614656, 616225, 617796, 619369, 620944, 622521, 624100, 625681, 627264, 628849, 630436, 632025, 633616, 635209, 636804, 638401, 640000, 641601, 643204, 644809, 646416, 648025, 649636, 651249, 652864, 654481, 656100, 657721, 659344, 660969, 662596, 664225, 665856, 667489, 669124, 670761, 672400, 674041, 675684, 677329, 678976, 680625, 682276, 683929, 685584, 687241, 688900, 690561, 692224, 693889, 695556, 697225, 698896, 700569, 702244, 703921, 705600, 707281, 708964, 710649, 712336, 714025, 715716, 717409, 719104, 720801, 722500, 724201, 725904, 727609, 729316, 731025, 732736, 734449, 736164, 737881, 739600, 741321, 743044, 744769, 746496, 748225, 749956, 751689, 753424, 755161, 756900, 758641, 760384, 762129, 763876, 765625, 767376, 769129, 770884, 772641, 774400, 776161, 777924, 779689, 781456, 783225, 784996, 786769, 788544, 790321, 792100, 793881, 795664, 797449, 799236, 801025, 802816, 804609, 806404, 808201, 810000, 811801, 813604, 815409, 817216, 819025, 820836, 822649, 824464, 826281, 828100, 829921, 831744, 833569, 835396, 837225, 839056, 840889, 842724, 844561, 846400, 848241, 850084, 851929, 853776, 855625, 857476, 859329, 861184, 863041, 864900, 866761, 868624, 870489, 872356, 874225, 876096, 877969, 879844, 881721, 883600, 885481, 887364, 889249, 891136, 893025, 894916, 896809, 898704, 900601, 902500, 904401, 906304, 908209, 910116, 912025, 913936, 915849, 917764, 919681, 921600, 923521, 925444, 927369, 929296, 931225, 933156, 935089, 937024, 938961, 940900, 942841, 944784, 946729, 948676, 950625, 952576, 954529, 956484, 958441, 960400, 962361, 964324, 966289, 968256, 970225, 972196, 974169, 976144, 978121, 980100, 982081, 984064, 986049, 988036, 990025, 992016, 994009, 996004, 998001]
120
<generator object main.<locals>.<genexpr> at 0x000002C8EB017A98>
1
4
9
16
25
36...

```

除了上面提到的生成器语法，Python中还有另外一种定义生成器的方式，就是通过yield关键字将一个普通函数改造成生成器函数。
下面的代码演示了如何实现一个生成斐波拉切数列的生成器。所谓斐波拉切数列可以通过下面递归的方法来进行定义：

F0=0
F1=1
Fn=Fn-1+Fn-2(n>=2)

```
 
def fib(n):
    a,b=0,1
    for _ in range(n):
        a,b=b,a+b
        #temp=a
        #a=b
        #b=temp+b
        yield a
def main():
    for val in fib(10):
        print(val)
if __name__=='__main__':
    main()
```


1
1
2
3
5
8
13
21
34
55...

# 使用元组
Python 的元组与列表类似，不同之处在于元组的元素不能修改，在前面的代码中我们已经不止一次使用过元组了。顾名思义，我们把多个元素组合到一起就形成了一个元组，所以它和列表一样可以保存多条数据。下面的代码演示了如何定义和使用元组
```
def main():
    #定义元组
    t=('张三',38,True,'四川成都')
    print(t)
    #获取元组中的元素
    print(t[0])
    print(t[3])
    #遍历元组中的值
    for member in t:
        print(member)
    #重新给元组赋值
    #t[0]='李四' #TypeError: 'tuple' object does not support item assignment
    #变量t重新引用了新的元组，原来的元组将被垃圾回收
    t=('王大锤',20,True,'云南昆明')
    print(t)
    #将元组转换成列表
    person=list(t)
    print(person)
    #列表时可以修改它的元素的
    person[0]='李小龙'
    person[1]=25
    print(person)
    #将列表转换成元组
    fruits_list=['apple','banana','orange']
    fruits_tuple=tuple(fruits_list)
    print(fruits_tuple)
if __name__=='__main__':
    main()
    
('张三', 38, True, '四川成都')
张三
四川成都
张三
38
True
四川成都
('王大锤', 20, True, '云南昆明')
['王大锤', 20, True, '云南昆明']
['李小龙', 25, True, '云南昆明']
('apple', 'banana', 'orange')
```

这里有一个非常值得探讨的问题，我们已经有了列表这种数据结构，为什么还需要元组这样的类型呢？
1 元组中的元素是无法修改的，事实上我们在项目中尤其是多线程环境（后面会讲到）中可能更喜欢使用的是那些不变对象（一方面因为对象状态不能修改，所以可以避免由此引起的不必要的程序错误，简单的说就是一个不变的对象要比可变的对象更加容易维护；另一方面因为没有任何一个线程能够修改不变对象的内部状态，一个不变对象自动就是线程安全的，这样就可以省掉处理同步化的开销。一个不变对象可以方便的被共享访问）。所以结论就是：如果不需要对元素进行添加、删除、修改的时候，可以考虑使用元组，当然如果一个方法要返回多个值，使用元组也是不错的选择。
2 元组在创建时间和占用的空间上面都优于列表。我们可以使用sys模块的getsizeof函数来检查存储同样的元素的元组和列表各自占用了多少内存空间，这个很容易做到。我们也可以在ipython中使用魔法指令%timeit来分析创建同样内容的元组和列表所花费的时间。

# 使用集合
Python中的集合跟数学上的集合是一致的，不允许有重复元素，而且可以进行交集、并集、差集等运算。
```

def main():
    set1={1,2,3,3,3,2}
    print(set1) #{1,2,3}
    print('length=',len(set1))# length=3
    set2=set(range(1,10))
    print(set2) #{1,2,3,4,5,6,7,8,9}
    set1.add(4)
    set1.add(5)
    set2.update([11,12])
    print(set1) #{1, 2, 3, 4, 5}
    print(set2) #{1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12}
    set2.discard(5)#将5去掉
    #remove 的元素如果不存在会引发KeyError
    if 4 in set2:
        set2.remove(4) #将4去掉
    print(set2)#{1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12}
    #遍历集合容器
    for elem in set2:
       print(elem**2,end=' ')#1 4 9 36 49 64 81 121 144
    print()
    #将元组转换成集合
    set3=set((1,2,3,3,2,1))
    print(set3.pop())
    print(set3)#{2, 3}
    # 集合的交集、并集、差集、对称差运算
    print(set1 & set2) #交集 {1, 2, 3}
    # 等价print(set1.intersection(set2))
    print(set1|set2)# 并集{1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12}
    #print(set1.union(set2))
    print(set1-set2)#差集{4, 5}
    #print(set1.difference(set2))
    print(set1^set2)#移除公共元素 {4, 5, 6, 7, 8, 9, 11, 12}
    #print(set1.symmetric_difference(set2))

    #判断子集和超集
    print(set2<=set1)
    #print(set2.issubset(set1)) #False
    print(set3<=set1)
    #print(set3.issubset(set1)) #True
    print(set1>=set3)
    #print(set1.issuperset(set3)) #True


if __name__=='__main__':
    main()
```

说明： Python中允许通过一些特殊的方法来为某种类型或数据结构自定义运算符（后面的章节中会讲到），上面的代码中我们对集合进行运算的时候可以调用集合对象的方法，也可以直接使用对应的运算符，例如&运算符跟intersection方法的作用就是一样的，但是使用运算符让代码更加直观。

# 使用字典
字典是另一种可变容器模型，类似于我们生活中使用的字典，它可以存储任意类型对象，与列表、集合不同的是，字典的每个元素都是由一个键和一个值组成的“键值对”，键和值通过冒号分开。下面的代码演示了如何定义和使用字典。

```

def main():
    scores={'张三':95,'李四':78,'赵五':82}
    #通过键可以获取字典中对应的值
    print(scores['张三'])
    print(scores['李四'])
    #对字典进行遍历（遍历其实是键再通过键去对应的值）
    for elem in scores:
        print('%s\t--->\t%d'%(elem,scores[elem]))
    #更新字典中的元素
    scores['白元芳']=65
    scores['诸葛王朗']=71
    scores.update(冷面=67,热面=85)
    print(scores)#{'张三': 95, '李四': 78, '赵五': 82, '白元芳': 65, '诸葛王朗': 71, '冷面': 67, '热面': 85}
    if '冷面' in scores:
        print(scores['冷面']) #67
    print(scores.get('冷面')) #67
    #get方法也是通过键获得对应的值但是可以设置默认值
    print(scores.get('武则天',60)) #60
    #删除字典中的元素
    print(scores.popitem()) #('热面', 85)
    print(scores.popitem()) #('冷面', 67)
    print(scores.pop('张三',95)) #95
    print(scores) #{'李四': 78, '赵五': 82, '白元芳': 65, '诸葛王朗': 71}
    #清空字典
    scores.clear()  
    print(scores) #{}

if __name__=='__main__':
    main()
```

# 练习
练习1：在屏幕上显示跑马灯文字
```
import os
import time
def main():
    content='北京欢迎你为你开天辟地......'
    while True:
        #清理屏幕上的输出
        os.system('cls') #os.system('clear')
        print(content)
        # 休眠200毫秒
        time.sleep(0.2)
        content=content[1:]+content[0]
if __name__=='__main__':
    main()
```


练习2：设计一个函数产生指定长度的验证码，验证码由大小写字母和数字构成。
```
import random
def generate_code(code_len=4):
    all_chars='0123456789abcdefghijklmnopqrstuvwxyz'
    last_pos=len(all_chars)-1
    code=''
    for _ in range(code_len):
        index=random.randint(0,last_pos)
        code+=all_chars[index]
    return code
if __name__=='__main__':
    print(generate_code())
```

练习3：设计一个函数返回给定文件名的后缀名
```
filename=input('输入文件名：')
len=len(filename)
num=0
for _ in range(len):
    if filename[_]=='.':
        num=_
print(filename[num+1:])
```

练习4：设计一个函数返回传入的列表中最大和第二大的元素的值。
```
n=int(input('即将输入几个数据：'))
num=[]
for _ in range(n):
    temp=int(input())
    num.append(temp)
for i in range(n):
    for j in range(n-1-i):
        if(num[j]>=num[j+1]):
            t=num[j]
            num[j]=num[j+1]
            num[j+1]=t
print(num[0],num[1])
```
